(ns {{ namespace }}
  (:require [gm.source.{{ source.type }} :as source]
            [gm.pipeline.core :as pipeline]
            [gm.sink.core :as sink]
            [gm.sink.{{ sink.type }} :as {{ sink.type }}]
            {% if watermark_enabled %}[gm.utils.watermark :as watermark]{% endif %}
            [clojure.tools.logging :as log])
  (:gen-class))

;; Configuration
(def config
  {:source {{ source_clojure_config }}

   :sink (merge {:type :{{ sink.type }}}
                {{ sink.config_template }})

   :pipeline {:batch-size {{ batch_size }}
              :source-table "{{ source.table }}"
              :source-type "{{ source.type }}"
              :dest-table "{{ sink.table }}"
              :timestamp-column :{{ timestamp_column }}
              :id-column :{{ id_column | default: "id" }}
              {% if watermark_enabled %}:watermark-file ".pipeline-watermark.edn"{% endif %}}})

(def transform-record (pipeline/make-transform-record config))

{% if watermark_enabled %}
;; Incremental pipeline execution
(defn run-incremental-pipeline []
  (log/info "Starting incremental {{ source.type }} -> {{ sink.type }} pipeline")
  (let [start-time (System/currentTimeMillis)
        watermark-file (:watermark-file (:pipeline config))
        wm (watermark/load-watermark watermark-file)
        timestamp-col (:timestamp-column (:pipeline config))
        id-col (:id-column (:pipeline config))]

    (log/info "Watermark stats:" (watermark/watermark-stats wm))

    (let [source-conn (-> (source/create-adapter)
                          (source/connect (:source config)))
          sink-conn (-> ({{ sink.type }}/create-adapter (:sink config))
                       (sink/connect (:sink config)))]

      (try
        (let [base-query (-> (source/query-spec (:source-table (:pipeline config)))
                             (source/select-columns [{% for col in columns %}:{{ col }} {% unless forloop.last %} {% endunless %}{% endfor %}]))
              
              ;; Build query based on watermark strategy
              query (cond
                      ;; Row-based watermark (CSV, etc.)
                      {% if source.watermark.type == "row_number" %}
                      wm
                      (let [last-row (:last-row-number wm)]
                        (log/info "Fetching records after row" last-row)
                        (source/offset base-query (inc last-row)))
                      
                      :else
                      (do
                        (log/info "No watermark found, fetching all records")
                        base-query)
                      {% else %}
                      ;; Timestamp-based watermark (databases)
                      wm
                      (let [incremental-condition (watermark/build-incremental-condition wm timestamp-col id-col)]
                        (log/info "Fetching records with composite condition")
                        (-> base-query
                            (source/where incremental-condition)
                            (source/allow-filtering)))
                      
                      :else
                      (do
                        (log/info "No watermark found, fetching all records")
                        base-query)
                      {% endif %})
              
              source-data (source/fetch source-conn query)
              
              ;; Filter for timestamp-based sources
              filtered-data {% if source.watermark.timestamp_based %}(watermark/filter-already-processed source-data wm timestamp-col id-col){% else %}source-data{% endif %}
              
              record-count (count filtered-data)]

          (log/info "Fetched" record-count "records")

          (if (zero? record-count)
            {:success true :records-processed 0 :message "No new data"}

            (let [transformed-data (map transform-record filtered-data)
                  
                  ;; Calculate watermark based on source type
                  {% if source.watermark.type == "row_number" %}
                  max-watermark (watermark/find-max-row-number filtered-data)
                  watermark-meta {}
                  {% else %}
                  [max-timestamp ids-at-max] (watermark/find-max-timestamp filtered-data timestamp-col id-col)
                  max-watermark max-timestamp
                  watermark-meta {:processed-ids (count ids-at-max)}
                  {% endif %}]

              (log/info "Max watermark:" max-watermark {% if source.watermark.uses_composite %}"with" (count ids-at-max) "records"{% endif %})

              (let [result (if (> record-count (:batch-size (:pipeline config)))
                             (sink/batch-insert sink-conn
                                               (:dest-table (:pipeline config))
                                               transformed-data
                                               (:batch-size (:pipeline config)))
                             (sink/insert sink-conn
                                         (:dest-table (:pipeline config))
                                         transformed-data))]

                ;; Save watermark based on source type
                {% if source.watermark.type == "row_number" %}
                (watermark/save-watermark watermark-file max-watermark
                                        {:records-processed record-count})
                {% else %}
                (watermark/save-watermark watermark-file max-watermark ids-at-max
                                        {:records-processed record-count})
                {% endif %}

                (merge
                 {:success true
                  :records-processed record-count
                  :elapsed-ms (- (System/currentTimeMillis) start-time)
                  :new-watermark max-watermark}
                 watermark-meta)))))

        (finally
          (source/disconnect source-conn)
          (sink/disconnect sink-conn))))))

;; Full reload
(defn run-full-reload []
  (log/info "Starting FULL RELOAD")
  (watermark/delete-watermark (:watermark-file (:pipeline config)))
  (run-incremental-pipeline))
{% endif %}

;; Regular pipeline
(defn run-pipeline []
  (log/info "Starting {{ source.type }} -> {{ sink.type }} pipeline")
    (let [start-time (System/currentTimeMillis)
          source-conn (-> (source/create-adapter)
                          (source/connect (:source config)))
          sink-conn (-> ({{ sink.type }}/create-adapter (:sink config))
                       (sink/connect (:sink config)))]
    (try
      (let [base-query (-> (source/query-spec (:source-table (:pipeline config)))
                          (source/select-columns [{% for col in columns %}:{{ col }} {% unless forloop.last %} {% endunless %}{% endfor %}]))

            ;; Apply static WHERE conditions if any
            {% if conditions.size > 0 %}
            where-conditions (pipeline/build-where-clause [
              {% for cond in conditions %}
              {:type :{{ cond.type }}
               :column :{{ cond.column }}
               {% if cond.type == "in_expression" %}
               :values [{{ cond.values_formatted }}]
               :negated {{ cond.negated }}
               {% else %}
               :operator "{{ cond.operator }}"
               :value {{ cond.value }}
               {% endif %}}{% unless forloop.last %},{% endunless %}
              {% endfor %}])
            
            query (source/where base-query where-conditions)
            {% else %}
            query base-query
            {% endif %}

            
            source-data (source/fetch source-conn query)
            record-count (count source-data)]

        (log/info "Fetched" record-count "records")

        (let [transformed-data (map transform-record source-data)
              result (sink/insert sink-conn
                                 (:dest-table (:pipeline config))
                                 transformed-data)]

          {:success true
           :records-processed record-count
           :elapsed-ms (- (System/currentTimeMillis) start-time)}))

      (finally
        (source/disconnect source-conn)
        (sink/disconnect sink-conn)))))

;; Main entry point
(defn -main [& args]
  (let [mode (first args)]
    (case mode
      {% if watermark_enabled %}"incremental" (run-incremental-pipeline)
      "full-reload" (run-full-reload)
      {% endif %}(run-pipeline))))
