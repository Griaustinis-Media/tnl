(ns {{ namespace }}
  (:require [gm.source.{{ source.type }} :as source]
            [gm.sink.core :as sink]
            [gm.sink.{{ sink.type }} :as {{ sink.type }}]
            {% if watermark_enabled %}[gm.utils.watermark :as watermark]{% endif %}
            [clojure.tools.logging :as log])
  (:gen-class))

;; Configuration
(def config
  {:{{ source.type }} {:contact-points [(or (System/getenv "{{ source.type | upcase }}_HOST") "{{ source.default_host }}")]
               :port {{ source.default_port }}
               :username (System/getenv "{{ source.type | upcase }}_USER")
               :password (System/getenv "{{ source.type | upcase }}_PASSWORD")
               {% if source.schema %}:keyspace "{{ source.schema }}"{% endif %}}

   :{{ sink.type }} {:base-url (or (System/getenv "{{ sink.type | upcase }}_URL") "{{ sink.default_url }}")
           :auth {:type :basic
                  :username (System/getenv "{{ sink.type | upcase }}_USER")
                  :password (System/getenv "{{ sink.type | upcase }}_PASSWORD")}}

   :pipeline {:batch-size {{ batch_size }}
              :source-table "{{ source.table }}"
              :dest-table "{{ sink.table }}"
              :timestamp-column :{{ timestamp_column }}
              {% if watermark_enabled %}:watermark-file ".pipeline-watermark.edn"{% endif %}}})

;; Data transformation
(defn transform-record
  "Transform {{ source.type }} record to {{ sink.type }} format"
  [record]
  (-> record
      (update (:timestamp-column (:pipeline config))
              #(cond
                 (instance? java.time.Instant %)
                 (.toString %)
                 
                 (instance? java.util.Date %)
                 (.format (java.text.SimpleDateFormat. "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'") %)
                 
                 :else %))
      (assoc :source "{{ source.type }}"
             :ingestion_time (System/currentTimeMillis))))

{% if watermark_enabled %}
;; Incremental pipeline execution
(defn run-incremental-pipeline []
  (log/info "Starting incremental {{ source.type }} -> {{ sink.type }} pipeline")
  (let [start-time (System/currentTimeMillis)
        watermark-file (:watermark-file (:pipeline config))
        wm (watermark/load-watermark watermark-file)
        timestamp-col (:timestamp-column (:pipeline config))]

    (log/info "Watermark stats:" (watermark/watermark-stats wm))

    (let [source-conn (-> (source/create-adapter)
                          (source/connect (:{{ source.type }} config)))
          sink-conn (-> ({{ sink.type }}/create-adapter (:{{ sink.type }} config))
                       (sink/connect (:{{ sink.type }} config)))]

      (try
        (let [base-query (-> (source/query-spec (:source-table (:pipeline config)))
                             (source/select-columns [{% for col in columns %}:{{ col }}{% unless forloop.last %} {% endunless %}{% endfor %}]))
              
              incremental-condition (watermark/build-incremental-condition wm timestamp-col)
              
              query (if incremental-condition
                      (do
                        (log/info "Fetching records with condition:" incremental-condition)
                        (-> base-query
                            (source/where incremental-condition)
                            (source/allow-filtering)))
                      (do
                        (log/info "No watermark found, fetching all records")
                        base-query))]

          (log/info "Fetching data from {{ source.type }}...")
          (let [source-data (source/fetch source-conn query)
                record-count (count source-data)]

            (if (zero? record-count)
              (do
                (log/info "No new records to process")
                {:success true :records-processed 0 :message "No new data"})

              (do
                (log/info "Fetched" record-count "new records")
                (let [transformed-data (map transform-record source-data)
                      max-timestamp (watermark/find-max-timestamp source-data timestamp-col)]

                  (log/info "Max timestamp in batch:" max-timestamp)

                  (let [result (if (> record-count (:batch-size (:pipeline config)))
                                 (sink/batch-insert sink-conn
                                                   (:dest-table (:pipeline config))
                                                   transformed-data
                                                   (:batch-size (:pipeline config)))
                                 (sink/insert sink-conn
                                             (:dest-table (:pipeline config))
                                             transformed-data))]

                    (watermark/save-watermark watermark-file max-timestamp
                                            {:records-processed record-count})

                    (let [elapsed (- (System/currentTimeMillis) start-time)]
                      {:success true
                       :records-processed record-count
                       :elapsed-ms elapsed
                       :previous-watermark (:last-timestamp wm)
                       :new-watermark max-timestamp})))))))

        (finally
          (source/disconnect source-conn)
          (sink/disconnect sink-conn))))))

;; Full reload
(defn run-full-reload []
  (log/info "Starting FULL RELOAD")
  (watermark/delete-watermark (:watermark-file (:pipeline config)))
  (run-incremental-pipeline))
{% endif %}

;; Regular pipeline
(defn run-pipeline []
  (log/info "Starting {{ source.type }} -> {{ sink.type }} pipeline")
  (let [start-time (System/currentTimeMillis)
        source-conn (-> (source/create-adapter)
                        (source/connect (:{{ source.type }} config)))
        sink-conn (-> ({{ sink.type }}/create-adapter (:{{ sink.type }} config))
                     (sink/connect (:{{ sink.type }} config)))]

    (try
      (let [query (source/query-spec (:source-table (:pipeline config)))
            source-data (source/fetch source-conn query)
            record-count (count source-data)]

        (log/info "Fetched" record-count "records")

        (let [transformed-data (map transform-record source-data)
              result (sink/insert sink-conn
                                 (:dest-table (:pipeline config))
                                 transformed-data)]

          {:success true
           :records-processed record-count
           :elapsed-ms (- (System/currentTimeMillis) start-time)}))

      (finally
        (source/disconnect source-conn)
        (sink/disconnect sink-conn)))))

;; Main entry point
(defn -main [& args]
  (let [mode (first args)]
    (case mode
      {% if watermark_enabled %}"incremental" (run-incremental-pipeline)
      "full-reload" (run-full-reload)
      {% endif %}(run-pipeline))))
